// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_GAMERESOURCE_H_
#define FLATBUFFERS_GENERATED_MODEL_GAMERESOURCE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace GameResource {

struct TexCoord;
struct TexCoordBuilder;

struct Vec3;
struct Vec3Builder;

struct Vec4;
struct Vec4Builder;

struct Material;
struct MaterialBuilder;

struct Vertex;
struct VertexBuilder;

struct Mesh;
struct MeshBuilder;

struct GeometryNode;
struct GeometryNodeBuilder;

struct GeometryModel;
struct GeometryModelBuilder;

enum AlphaMode : int16_t {
  AlphaMode_kOpaque = 0,
  AlphaMode_kMask = 1,
  AlphaMode_kBlend = 2,
  AlphaMode_MIN = AlphaMode_kOpaque,
  AlphaMode_MAX = AlphaMode_kBlend
};

inline const AlphaMode (&EnumValuesAlphaMode())[3] {
  static const AlphaMode values[] = {
    AlphaMode_kOpaque,
    AlphaMode_kMask,
    AlphaMode_kBlend
  };
  return values;
}

inline const char * const *EnumNamesAlphaMode() {
  static const char * const names[4] = {
    "kOpaque",
    "kMask",
    "kBlend",
    nullptr
  };
  return names;
}

inline const char *EnumNameAlphaMode(AlphaMode e) {
  if (::flatbuffers::IsOutRange(e, AlphaMode_kOpaque, AlphaMode_kBlend)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAlphaMode()[index];
}

struct TexCoord FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TexCoordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_U = 4,
    VT_V = 6
  };
  float u() const {
    return GetField<float>(VT_U, 0.0f);
  }
  float v() const {
    return GetField<float>(VT_V, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_U, 4) &&
           VerifyField<float>(verifier, VT_V, 4) &&
           verifier.EndTable();
  }
};

struct TexCoordBuilder {
  typedef TexCoord Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_u(float u) {
    fbb_.AddElement<float>(TexCoord::VT_U, u, 0.0f);
  }
  void add_v(float v) {
    fbb_.AddElement<float>(TexCoord::VT_V, v, 0.0f);
  }
  explicit TexCoordBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TexCoord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TexCoord>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TexCoord> CreateTexCoord(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float u = 0.0f,
    float v = 0.0f) {
  TexCoordBuilder builder_(_fbb);
  builder_.add_v(v);
  builder_.add_u(u);
  return builder_.Finish();
}

struct Vec3 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Vec3Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           verifier.EndTable();
  }
};

struct Vec3Builder {
  typedef Vec3 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Vec3::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Vec3::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Vec3::VT_Z, z, 0.0f);
  }
  explicit Vec3Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vec3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vec3>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Vec3> CreateVec3(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  Vec3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Vec4 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Vec4Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8,
    VT_W = 10
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  float w() const {
    return GetField<float>(VT_W, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           VerifyField<float>(verifier, VT_W, 4) &&
           verifier.EndTable();
  }
};

struct Vec4Builder {
  typedef Vec4 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Vec4::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Vec4::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Vec4::VT_Z, z, 0.0f);
  }
  void add_w(float w) {
    fbb_.AddElement<float>(Vec4::VT_W, w, 0.0f);
  }
  explicit Vec4Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vec4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vec4>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Vec4> CreateVec4(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    float w = 0.0f) {
  Vec4Builder builder_(_fbb);
  builder_.add_w(w);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Material FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaterialBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ALBEDOFACTOR = 6,
    VT_ALBEDOTEXTURE = 8,
    VT_METALLICFACTOR = 10,
    VT_ROUGHNESSFACTOR = 12,
    VT_METALLICROUGHNESSTEXTURE = 14,
    VT_NORMALTEXTURE = 16,
    VT_OCCLUSIONTEXTURE = 18,
    VT_EMISSIVEFACTOR = 20,
    VT_EMISSIVETEXTURE = 22,
    VT_ALPHAMODE = 24,
    VT_ALPHACUTOFF = 26,
    VT_DOUBLESIDED = 28
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const GameResource::Vec4 *albedoFactor() const {
    return GetPointer<const GameResource::Vec4 *>(VT_ALBEDOFACTOR);
  }
  const ::flatbuffers::String *albedoTexture() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALBEDOTEXTURE);
  }
  float metallicFactor() const {
    return GetField<float>(VT_METALLICFACTOR, 0.0f);
  }
  float roughnessFactor() const {
    return GetField<float>(VT_ROUGHNESSFACTOR, 0.0f);
  }
  const ::flatbuffers::String *metallicRoughnessTexture() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METALLICROUGHNESSTEXTURE);
  }
  const ::flatbuffers::String *normalTexture() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NORMALTEXTURE);
  }
  const ::flatbuffers::String *occlusionTexture() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OCCLUSIONTEXTURE);
  }
  float emissiveFactor() const {
    return GetField<float>(VT_EMISSIVEFACTOR, 0.0f);
  }
  const ::flatbuffers::String *emissiveTexture() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EMISSIVETEXTURE);
  }
  GameResource::AlphaMode alphaMode() const {
    return static_cast<GameResource::AlphaMode>(GetField<int16_t>(VT_ALPHAMODE, 0));
  }
  float alphaCutoff() const {
    return GetField<float>(VT_ALPHACUTOFF, 0.0f);
  }
  bool doubleSided() const {
    return GetField<uint8_t>(VT_DOUBLESIDED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ALBEDOFACTOR) &&
           verifier.VerifyTable(albedoFactor()) &&
           VerifyOffset(verifier, VT_ALBEDOTEXTURE) &&
           verifier.VerifyString(albedoTexture()) &&
           VerifyField<float>(verifier, VT_METALLICFACTOR, 4) &&
           VerifyField<float>(verifier, VT_ROUGHNESSFACTOR, 4) &&
           VerifyOffset(verifier, VT_METALLICROUGHNESSTEXTURE) &&
           verifier.VerifyString(metallicRoughnessTexture()) &&
           VerifyOffset(verifier, VT_NORMALTEXTURE) &&
           verifier.VerifyString(normalTexture()) &&
           VerifyOffset(verifier, VT_OCCLUSIONTEXTURE) &&
           verifier.VerifyString(occlusionTexture()) &&
           VerifyField<float>(verifier, VT_EMISSIVEFACTOR, 4) &&
           VerifyOffset(verifier, VT_EMISSIVETEXTURE) &&
           verifier.VerifyString(emissiveTexture()) &&
           VerifyField<int16_t>(verifier, VT_ALPHAMODE, 2) &&
           VerifyField<float>(verifier, VT_ALPHACUTOFF, 4) &&
           VerifyField<uint8_t>(verifier, VT_DOUBLESIDED, 1) &&
           verifier.EndTable();
  }
};

struct MaterialBuilder {
  typedef Material Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Material::VT_NAME, name);
  }
  void add_albedoFactor(::flatbuffers::Offset<GameResource::Vec4> albedoFactor) {
    fbb_.AddOffset(Material::VT_ALBEDOFACTOR, albedoFactor);
  }
  void add_albedoTexture(::flatbuffers::Offset<::flatbuffers::String> albedoTexture) {
    fbb_.AddOffset(Material::VT_ALBEDOTEXTURE, albedoTexture);
  }
  void add_metallicFactor(float metallicFactor) {
    fbb_.AddElement<float>(Material::VT_METALLICFACTOR, metallicFactor, 0.0f);
  }
  void add_roughnessFactor(float roughnessFactor) {
    fbb_.AddElement<float>(Material::VT_ROUGHNESSFACTOR, roughnessFactor, 0.0f);
  }
  void add_metallicRoughnessTexture(::flatbuffers::Offset<::flatbuffers::String> metallicRoughnessTexture) {
    fbb_.AddOffset(Material::VT_METALLICROUGHNESSTEXTURE, metallicRoughnessTexture);
  }
  void add_normalTexture(::flatbuffers::Offset<::flatbuffers::String> normalTexture) {
    fbb_.AddOffset(Material::VT_NORMALTEXTURE, normalTexture);
  }
  void add_occlusionTexture(::flatbuffers::Offset<::flatbuffers::String> occlusionTexture) {
    fbb_.AddOffset(Material::VT_OCCLUSIONTEXTURE, occlusionTexture);
  }
  void add_emissiveFactor(float emissiveFactor) {
    fbb_.AddElement<float>(Material::VT_EMISSIVEFACTOR, emissiveFactor, 0.0f);
  }
  void add_emissiveTexture(::flatbuffers::Offset<::flatbuffers::String> emissiveTexture) {
    fbb_.AddOffset(Material::VT_EMISSIVETEXTURE, emissiveTexture);
  }
  void add_alphaMode(GameResource::AlphaMode alphaMode) {
    fbb_.AddElement<int16_t>(Material::VT_ALPHAMODE, static_cast<int16_t>(alphaMode), 0);
  }
  void add_alphaCutoff(float alphaCutoff) {
    fbb_.AddElement<float>(Material::VT_ALPHACUTOFF, alphaCutoff, 0.0f);
  }
  void add_doubleSided(bool doubleSided) {
    fbb_.AddElement<uint8_t>(Material::VT_DOUBLESIDED, static_cast<uint8_t>(doubleSided), 0);
  }
  explicit MaterialBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Material> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Material>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Material> CreateMaterial(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<GameResource::Vec4> albedoFactor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> albedoTexture = 0,
    float metallicFactor = 0.0f,
    float roughnessFactor = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> metallicRoughnessTexture = 0,
    ::flatbuffers::Offset<::flatbuffers::String> normalTexture = 0,
    ::flatbuffers::Offset<::flatbuffers::String> occlusionTexture = 0,
    float emissiveFactor = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> emissiveTexture = 0,
    GameResource::AlphaMode alphaMode = GameResource::AlphaMode_kOpaque,
    float alphaCutoff = 0.0f,
    bool doubleSided = false) {
  MaterialBuilder builder_(_fbb);
  builder_.add_alphaCutoff(alphaCutoff);
  builder_.add_emissiveTexture(emissiveTexture);
  builder_.add_emissiveFactor(emissiveFactor);
  builder_.add_occlusionTexture(occlusionTexture);
  builder_.add_normalTexture(normalTexture);
  builder_.add_metallicRoughnessTexture(metallicRoughnessTexture);
  builder_.add_roughnessFactor(roughnessFactor);
  builder_.add_metallicFactor(metallicFactor);
  builder_.add_albedoTexture(albedoTexture);
  builder_.add_albedoFactor(albedoFactor);
  builder_.add_name(name);
  builder_.add_alphaMode(alphaMode);
  builder_.add_doubleSided(doubleSided);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Material> CreateMaterialDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<GameResource::Vec4> albedoFactor = 0,
    const char *albedoTexture = nullptr,
    float metallicFactor = 0.0f,
    float roughnessFactor = 0.0f,
    const char *metallicRoughnessTexture = nullptr,
    const char *normalTexture = nullptr,
    const char *occlusionTexture = nullptr,
    float emissiveFactor = 0.0f,
    const char *emissiveTexture = nullptr,
    GameResource::AlphaMode alphaMode = GameResource::AlphaMode_kOpaque,
    float alphaCutoff = 0.0f,
    bool doubleSided = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto albedoTexture__ = albedoTexture ? _fbb.CreateString(albedoTexture) : 0;
  auto metallicRoughnessTexture__ = metallicRoughnessTexture ? _fbb.CreateString(metallicRoughnessTexture) : 0;
  auto normalTexture__ = normalTexture ? _fbb.CreateString(normalTexture) : 0;
  auto occlusionTexture__ = occlusionTexture ? _fbb.CreateString(occlusionTexture) : 0;
  auto emissiveTexture__ = emissiveTexture ? _fbb.CreateString(emissiveTexture) : 0;
  return GameResource::CreateMaterial(
      _fbb,
      name__,
      albedoFactor,
      albedoTexture__,
      metallicFactor,
      roughnessFactor,
      metallicRoughnessTexture__,
      normalTexture__,
      occlusionTexture__,
      emissiveFactor,
      emissiveTexture__,
      alphaMode,
      alphaCutoff,
      doubleSided);
}

struct Vertex FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VertexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_NORMAL = 6,
    VT_TANGENT = 8,
    VT_BITANGENT = 10,
    VT_TEXCOORD = 12,
    VT_COLOR = 14
  };
  const GameResource::Vec4 *position() const {
    return GetPointer<const GameResource::Vec4 *>(VT_POSITION);
  }
  const GameResource::Vec3 *normal() const {
    return GetPointer<const GameResource::Vec3 *>(VT_NORMAL);
  }
  const GameResource::Vec3 *tangent() const {
    return GetPointer<const GameResource::Vec3 *>(VT_TANGENT);
  }
  const GameResource::Vec3 *bitangent() const {
    return GetPointer<const GameResource::Vec3 *>(VT_BITANGENT);
  }
  const GameResource::TexCoord *texcoord() const {
    return GetPointer<const GameResource::TexCoord *>(VT_TEXCOORD);
  }
  const GameResource::Vec4 *color() const {
    return GetPointer<const GameResource::Vec4 *>(VT_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffset(verifier, VT_NORMAL) &&
           verifier.VerifyTable(normal()) &&
           VerifyOffset(verifier, VT_TANGENT) &&
           verifier.VerifyTable(tangent()) &&
           VerifyOffset(verifier, VT_BITANGENT) &&
           verifier.VerifyTable(bitangent()) &&
           VerifyOffset(verifier, VT_TEXCOORD) &&
           verifier.VerifyTable(texcoord()) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           verifier.EndTable();
  }
};

struct VertexBuilder {
  typedef Vertex Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(::flatbuffers::Offset<GameResource::Vec4> position) {
    fbb_.AddOffset(Vertex::VT_POSITION, position);
  }
  void add_normal(::flatbuffers::Offset<GameResource::Vec3> normal) {
    fbb_.AddOffset(Vertex::VT_NORMAL, normal);
  }
  void add_tangent(::flatbuffers::Offset<GameResource::Vec3> tangent) {
    fbb_.AddOffset(Vertex::VT_TANGENT, tangent);
  }
  void add_bitangent(::flatbuffers::Offset<GameResource::Vec3> bitangent) {
    fbb_.AddOffset(Vertex::VT_BITANGENT, bitangent);
  }
  void add_texcoord(::flatbuffers::Offset<GameResource::TexCoord> texcoord) {
    fbb_.AddOffset(Vertex::VT_TEXCOORD, texcoord);
  }
  void add_color(::flatbuffers::Offset<GameResource::Vec4> color) {
    fbb_.AddOffset(Vertex::VT_COLOR, color);
  }
  explicit VertexBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vertex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vertex>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Vertex> CreateVertex(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<GameResource::Vec4> position = 0,
    ::flatbuffers::Offset<GameResource::Vec3> normal = 0,
    ::flatbuffers::Offset<GameResource::Vec3> tangent = 0,
    ::flatbuffers::Offset<GameResource::Vec3> bitangent = 0,
    ::flatbuffers::Offset<GameResource::TexCoord> texcoord = 0,
    ::flatbuffers::Offset<GameResource::Vec4> color = 0) {
  VertexBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_texcoord(texcoord);
  builder_.add_bitangent(bitangent);
  builder_.add_tangent(tangent);
  builder_.add_normal(normal);
  builder_.add_position(position);
  return builder_.Finish();
}

struct Mesh FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MeshBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERTICES = 6,
    VT_INDICES = 8,
    VT_MATERIAL = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GameResource::Vertex>> *vertices() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GameResource::Vertex>> *>(VT_VERTICES);
  }
  const ::flatbuffers::Vector<uint32_t> *indices() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_INDICES);
  }
  const ::flatbuffers::String *material() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATERIAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VERTICES) &&
           verifier.VerifyVector(vertices()) &&
           verifier.VerifyVectorOfTables(vertices()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyString(material()) &&
           verifier.EndTable();
  }
};

struct MeshBuilder {
  typedef Mesh Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Mesh::VT_NAME, name);
  }
  void add_vertices(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameResource::Vertex>>> vertices) {
    fbb_.AddOffset(Mesh::VT_VERTICES, vertices);
  }
  void add_indices(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> indices) {
    fbb_.AddOffset(Mesh::VT_INDICES, indices);
  }
  void add_material(::flatbuffers::Offset<::flatbuffers::String> material) {
    fbb_.AddOffset(Mesh::VT_MATERIAL, material);
  }
  explicit MeshBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Mesh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Mesh>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Mesh> CreateMesh(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameResource::Vertex>>> vertices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> indices = 0,
    ::flatbuffers::Offset<::flatbuffers::String> material = 0) {
  MeshBuilder builder_(_fbb);
  builder_.add_material(material);
  builder_.add_indices(indices);
  builder_.add_vertices(vertices);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Mesh> CreateMeshDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<GameResource::Vertex>> *vertices = nullptr,
    const std::vector<uint32_t> *indices = nullptr,
    const char *material = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto vertices__ = vertices ? _fbb.CreateVector<::flatbuffers::Offset<GameResource::Vertex>>(*vertices) : 0;
  auto indices__ = indices ? _fbb.CreateVector<uint32_t>(*indices) : 0;
  auto material__ = material ? _fbb.CreateString(material) : 0;
  return GameResource::CreateMesh(
      _fbb,
      name__,
      vertices__,
      indices__,
      material__);
}

struct GeometryNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeometryNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_LEVEL = 6,
    VT_PARENT = 8,
    VT_FIRSTCHILD = 10,
    VT_NEXTSIBLING = 12,
    VT_MESHES = 14
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t parent() const {
    return GetField<int32_t>(VT_PARENT, 0);
  }
  int32_t firstChild() const {
    return GetField<int32_t>(VT_FIRSTCHILD, 0);
  }
  int32_t nextSibling() const {
    return GetField<int32_t>(VT_NEXTSIBLING, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *meshes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MESHES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL, 4) &&
           VerifyField<int32_t>(verifier, VT_PARENT, 4) &&
           VerifyField<int32_t>(verifier, VT_FIRSTCHILD, 4) &&
           VerifyField<int32_t>(verifier, VT_NEXTSIBLING, 4) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           verifier.VerifyVectorOfStrings(meshes()) &&
           verifier.EndTable();
  }
};

struct GeometryNodeBuilder {
  typedef GeometryNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(GeometryNode::VT_NAME, name);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(GeometryNode::VT_LEVEL, level, 0);
  }
  void add_parent(int32_t parent) {
    fbb_.AddElement<int32_t>(GeometryNode::VT_PARENT, parent, 0);
  }
  void add_firstChild(int32_t firstChild) {
    fbb_.AddElement<int32_t>(GeometryNode::VT_FIRSTCHILD, firstChild, 0);
  }
  void add_nextSibling(int32_t nextSibling) {
    fbb_.AddElement<int32_t>(GeometryNode::VT_NEXTSIBLING, nextSibling, 0);
  }
  void add_meshes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> meshes) {
    fbb_.AddOffset(GeometryNode::VT_MESHES, meshes);
  }
  explicit GeometryNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeometryNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeometryNode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GeometryNode> CreateGeometryNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t level = 0,
    int32_t parent = 0,
    int32_t firstChild = 0,
    int32_t nextSibling = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> meshes = 0) {
  GeometryNodeBuilder builder_(_fbb);
  builder_.add_meshes(meshes);
  builder_.add_nextSibling(nextSibling);
  builder_.add_firstChild(firstChild);
  builder_.add_parent(parent);
  builder_.add_level(level);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GeometryNode> CreateGeometryNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t level = 0,
    int32_t parent = 0,
    int32_t firstChild = 0,
    int32_t nextSibling = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *meshes = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto meshes__ = meshes ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*meshes) : 0;
  return GameResource::CreateGeometryNode(
      _fbb,
      name__,
      level,
      parent,
      firstChild,
      nextSibling,
      meshes__);
}

struct GeometryModel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeometryModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NODES = 6,
    VT_MESHES = 8,
    VT_MATERIALS = 10,
    VT_TEXTURES = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GameResource::GeometryNode>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GameResource::GeometryNode>> *>(VT_NODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *meshes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MESHES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *materials() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MATERIALS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *textures() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TEXTURES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           verifier.VerifyVectorOfStrings(meshes()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(materials()) &&
           verifier.VerifyVectorOfStrings(materials()) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.VerifyVector(textures()) &&
           verifier.VerifyVectorOfStrings(textures()) &&
           verifier.EndTable();
  }
};

struct GeometryModelBuilder {
  typedef GeometryModel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(GeometryModel::VT_NAME, name);
  }
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameResource::GeometryNode>>> nodes) {
    fbb_.AddOffset(GeometryModel::VT_NODES, nodes);
  }
  void add_meshes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> meshes) {
    fbb_.AddOffset(GeometryModel::VT_MESHES, meshes);
  }
  void add_materials(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> materials) {
    fbb_.AddOffset(GeometryModel::VT_MATERIALS, materials);
  }
  void add_textures(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> textures) {
    fbb_.AddOffset(GeometryModel::VT_TEXTURES, textures);
  }
  explicit GeometryModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeometryModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeometryModel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GeometryModel> CreateGeometryModel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameResource::GeometryNode>>> nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> meshes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> materials = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> textures = 0) {
  GeometryModelBuilder builder_(_fbb);
  builder_.add_textures(textures);
  builder_.add_materials(materials);
  builder_.add_meshes(meshes);
  builder_.add_nodes(nodes);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GeometryModel> CreateGeometryModelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<GameResource::GeometryNode>> *nodes = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *meshes = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *materials = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *textures = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<::flatbuffers::Offset<GameResource::GeometryNode>>(*nodes) : 0;
  auto meshes__ = meshes ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*meshes) : 0;
  auto materials__ = materials ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*materials) : 0;
  auto textures__ = textures ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*textures) : 0;
  return GameResource::CreateGeometryModel(
      _fbb,
      name__,
      nodes__,
      meshes__,
      materials__,
      textures__);
}

inline const GameResource::GeometryModel *GetGeometryModel(const void *buf) {
  return ::flatbuffers::GetRoot<GameResource::GeometryModel>(buf);
}

inline const GameResource::GeometryModel *GetSizePrefixedGeometryModel(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<GameResource::GeometryModel>(buf);
}

inline bool VerifyGeometryModelBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GameResource::GeometryModel>(nullptr);
}

inline bool VerifySizePrefixedGeometryModelBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GameResource::GeometryModel>(nullptr);
}

inline void FinishGeometryModelBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GameResource::GeometryModel> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGeometryModelBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GameResource::GeometryModel> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace GameResource

#endif  // FLATBUFFERS_GENERATED_MODEL_GAMERESOURCE_H_
